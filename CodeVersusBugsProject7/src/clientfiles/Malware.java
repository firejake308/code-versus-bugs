/**Malware.java
 * Handles movement and drawing of malware.
 * 
 * UPDATE LOG
 * 11/1/14:	
 * 		speed is now in pixels per second
 * 		x, y, and distance are now doubles for more fine tuning
 * 		made checkpoint variables for future use in implementing different paths
 * 11/2/14:	
 * 		drawVirus and moveVirus are no longer static for more logical code
 * 11/12/14:
 * 		2 paths now exist for viruses to follow
 * 		implemented directions and path arrays in moveVirus()
 * 11/15/14:
 * 		added lanes 3,4 and 5 
 * 		[BALANCE] reduced income from viruses ($10 -> $5)
 * 11/23/14:
 * 		added freezing ability and framework for future abilities
 * 11/27/14:
 * 		[BALANCE] increased speed of virus (20 -> 35)
 * TODO
 * see if we are done with this class for now
 * 
 * ----------------------------------------------------------------------
 * 
 * Copyright 2014 Adel Hassan and Patrick Kenney
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package clientfiles;

import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.geom.AffineTransform;
import java.awt.image.ImageObserver;

import javax.swing.ImageIcon;

public abstract class Malware
{
	// for special effects and abilities
	public enum State
	{
		NORMAL, FROZEN, ATTACKING
	}
	
	public static Malware allMalware[] = new Malware[10000];
	public static int numMalwares = 0;
	public static final int NORMAL = 0;
	public static final int TANK = 1;
	public static final int RUSH = 2;
	
	public double manipulator = 1;
	public int id;
	protected int health;
	protected double x;
	protected double y;
	protected double distance;
	protected int reward;
	protected double elapsedTime = 0;
	protected State state = State.NORMAL;
	public Image sprite;
	private int w = Game.widthOfGamePanel;
	private int h = Game.heightOfGamePanel;
	public int speed;
	public int type;
	
	//lanes
	protected final int[] lane1 = {
			h / 4 - w / 84 * 3, // w / 42
			h / 4 - w / 84 * 5  + (int) (w * .15),
			h / 4 - w / 84 * 7  + (int) (w * .15) + (int) (h * .4),
			h / 4 - w / 84 * 7  + (int) (w * .15) + (int) (h * .4) + w / 5,
			h / 4 - w / 84 * 9  + (int) (w * .15) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42,
			h / 4 - w / 84 * 11 + (int) (w * .15) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5,
			h / 4 - w / 84 * 13 + (int) (w * .15) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2,
			h / 4 - w / 84 * 15 + (int) (w * .15) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + (int) (w * .3) + w / 42,
			h / 4 - w / 84 * 15 + (int) (w * .15) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + (int) (w * .3) + w / 42 + (int) (h * .15)};
	protected final int[] directions1 = {1,1,1,1,-1,1,1,-1,1};
	protected final int[] lane2 = {
			h / 4 - w / 84 * 3,
			h / 4 - w / 84 * 3  + (int) (w * .05),
			h / 4 - w / 84 * 5  + (int) (w * .05) + (int) (h * .4),
			h / 4 - w / 84 * 5  + (int) (w * .05) + (int) (h * .4) + w / 5,
			h / 4 - w / 84 * 7  + (int) (w * .05) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42,
			h / 4 - w / 84 * 9  + (int) (w * .05) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5,
			h / 4 - w / 84 * 11 + (int) (w * .05) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2,
			h / 4 - w / 84 * 13 + (int) (w * .05) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + (int) (w * .3) + w / 42,
			h / 4 - w / 84 * 13 + (int) (w * .05) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + (int) (w * .3) + w / 42 + (int) (h * .15)};
	protected final int[] directions2 = {1,-1,1,1,-1,1,1,-1,1};
	protected final int[] lane3 = {
			h / 4 - w / 84 * 3,
			h / 4 - w / 84 * 1  + (int) (w * .18),
			h / 4 - w / 84 * 3  + (int) (w * .18) + (int) (h * .4),
			h / 4 - w / 84 * 3  + (int) (w * .18) + (int) (h * .4) + w / 5,
			h / 4 - w / 84 * 5  + (int) (w * .18) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42,
			h / 4 - w / 84 * 7  + (int) (w * .18) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5,
			h / 4 - w / 84 * 9  + (int) (w * .18) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2,
			h / 4 - w / 84 * 11 + (int) (w * .18) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + (int) (w * .3) + w / 42,
			h / 4 - w / 84 * 10 + (int) (w * .18) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + (int) (w * .3) + w / 42 + (int) (h * .15)};

	protected final int[] directions3 = {1,-1,1,1,-1,1,1,-1,1};
	protected final int[] lane4 = {
			(int) (h * .4) - w / 84 * 3,
			(int) (h * .4) - w / 84 * 2 + (int) (w * .14),
			(int) (h * .4) - w / 84 * 2 + (int) (w * .14) + (int) (h * .3),
			(int) (h * .4) - w / 84 * 4 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42),
			(int) (h * .4) - w / 84 * 5 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22),
			(int) (h * .4) - w / 84 * 7 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + (int) (w * .3) + w / 42,
			(int) (h * .4) - w / 84 * 7 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + (int) (w * .3) + w / 42 + (int) (h * .15),
			(int) (h * .4) - w / 84 * 7 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + (int) (w * .3) + w / 42 + (int) (h * .15) + 1,
			(int) (h * .4) - w / 84 * 7 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + (int) (w * .3) + w / 42 + (int) (h * .15) + 2};
	protected final int[] directions4 = {1,1,1,-1,1,-1,1,0,0};
	protected final int[] lane5 = {
			(int) (h * .4) - w / 84 * 3,
			(int) (h * .4) - w / 84 * 3 + (int) (w * .05),
			(int) (h * .4) - w / 84 * 3 + (int) (w * .05) + (int) (h * .3),
			(int) (h * .4) - w / 84 * 5 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42),
			(int) (h * .4) - w / 84 * 6 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22),
			(int) (h * .4) - w / 84 * 8 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + (int) (w * .3) + w / 42,
			(int) (h * .4) - w / 84 * 8 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + (int) (w * .3) + w / 42 + (int) (h * .15),
			(int) (h * .4) - w / 84 * 8 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + (int) (w * .3) + w / 42 + (int) (h * .15) + 1,
			(int) (h * .4) - w / 84 * 8 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + (int) (w * .3) + w / 42 + (int) (h * .15) + 2};
	protected final int[] directions5 = {1,-1,1,-1,1,-1,1,0,0};
	protected int[] path;
	protected int[] directions;
	
	/**creates a virus in the lane specified, at the chosen y value. 
	 * Lanes are numbered from left to right.
	 * 
	 * @param y
	 */
	public Malware(int type, int lane, int y)
	{
		setY(y);
		setDistance(y);
		
		//id should correspond to virus's location in allMalware array
		id = numMalwares;
		//code for setting sprite based on malware type
		//CANT be done in subclasses because setCenterX() needs a non-null sprite
		if(this instanceof Minion)
		{
			if(type == NORMAL)
				sprite=Minion.sprite;
			else if(type == TANK)
				sprite=Minion.tankSprite;
			else if(type == RUSH)
				sprite = Minion.rushSprite;
		}
		else if(this instanceof Worm)
			sprite=Worm.sprite;
		
		numMalwares++;
		
		switch(lane)
		{
			case 1:
				path = lane1;
				directions = directions1;
				setCenterX(w / 14 + (w / 84));
				break;
			case 2:
				path = lane2;
				directions = directions2;
				setCenterX(w / 4 + (w / 84));
				break;
			case 3:
				path = lane3;
				directions = directions3;
				setCenterX((int) (w * .4) + (w / 84));
				break;
			case 4:
				path = lane4;
				directions = directions4;
				setCenterX((int) (w * .65) + (w / 84));
				break;
			case 5:
				path = lane5;
				directions = directions5;
				setCenterX((int) (w * .85) + (w / 84));
				break;
			default:
				path = lane1;
				directions = directions1;
				setCenterX(w / 14 - (w / 84));
		}
	}
	
	/**deals damage to the selected virus equal to the argument's value
	 * 
	 * @param damage
	 */
	public void dealDamage(int damage, double manipulatorToSet, int idOfTower)
	{
		manipulator = manipulatorToSet;
		
		if (manipulatorToSet == 0)
			state = State.FROZEN;
		
		health -= damage;
		
		// increase number of hits for killer
		if (Tower.allTowers[idOfTower] != null)
			Tower.allTowers[idOfTower].hits++;
		
		if(health <= 0)
		{
			Game.money += reward;
			Game.gf.moneyLabel.setText("$" + Game.money + " money");
			
			// increase number of kills for killer
			if (Tower.allTowers[idOfTower] != null)
				Tower.allTowers[idOfTower].kills++;
			
			despawn();
		}
		
		// re-draw tower panel with updated statistics
		if (idOfTower == Upgrades.displayedUpgradeID && Tower.allTowers[idOfTower] != null)
			Upgrades.updateStatistics();
	}

	/**
	 * Removes the virus from the allMalware array.
	 */
	public void despawn()
	{
		//save the dead virus's ID and reduce total number of viruses
		int deadVirusID=id;
		numMalwares--;
		
		//move all other viruses in array
		for(int v=deadVirusID; v<allMalware.length; v++)
		{
			allMalware[v] = allMalware[v+1];
			
			//break once reaches the nulls
			if(allMalware[v] == null)
				break;
			
			//change the virus's id to its new location in the array
			allMalware[v].id = v;
		}
		
		if (numMalwares == 0)
		{
			Game.gameState = Game.PAUSED;
			Game.pauseButton.setIcon(PauseButtonListener.sprite);
			Game.money += 50;
			Game.gf.moneyLabel.setText("$" + Game.money + " money");
			
			Game.level++;
			Game.gf.life.setText("Lives: " + Game.lives);
			Game.gf.levelCounter.setText("Level: " + Game.level);
			
			Game.gamePanel.setVisible(false);
			Game.techPanel.setVisible(true);
			
			// removed start next round and replaced with variable that is used in actionlistener for Game class to decide when to start next round - 3:08pm - 11/24/2014
			Game.endOfRound = true;
		}
	}
	public void drawVirus(Graphics g)
	{
		if(health>0)
		{
			AffineTransform at = new AffineTransform();
			at.scale(Game.scaleOfSprites, Game.scaleOfSprites);
			at.translate((int)getX() / Game.scaleOfSprites, (int) getY() / Game.scaleOfSprites);
			Graphics2D g2D = (Graphics2D) g;
			g2D.drawImage(sprite, at, null);
			
			//g.drawImage(sprite, (int)getX()+GamePanel.getMapX(), (int)getY()+GamePanel.getMapY(), null);
		}
	}
	public int getCenterX()
	{
		return (int) x + sprite.getWidth(null)/2;
	}
	public int getCenterY()
	{
		return (int) y + sprite.getHeight(null)/2;
	}
	public double getDistance()
	{
		return distance;
	}
	public int getHealth()
	{
		return health;
	}
	// for use in targeting
	public double getRelativeDistance()
	{
		if (getCenterY() < 0)
			return distance;
		else if (path == lane1)
			return distance + 47;
		else if (path == lane2)
			return distance + 131;
		else if (path == lane3)
			return distance;
		else if (path == lane4)
			return distance + 337;
		else if (path == lane5)
			return distance + 457;
		else
			return distance;
	}
	public double getX()
	{
		return x;
	}
	public double getY()
	{
		return y;
	}
	
	/**call this method on a virus object to move the virus
	 * where frames is the interpolation
	 * 
	 * @param frames
	 */
	public void moveVirus(double frames)
	{
		// timer for frozen viruses
				if (state == State.FROZEN && elapsedTime < 5)
				{
					elapsedTime += frames/60;
					if (Game.fastForward)
						elapsedTime += frames/60;
				}
				// to be changed later
				else // reseting
				{
					manipulator = 1;
					elapsedTime = 0;
					state = State.NORMAL;
				}
				
				//move down for first stretch
				if(getDistance()<path[0]) //if distance traveled is less than 2st item in array, then move down
				{
					setY(getY()+directions[0]*speed*frames/60*manipulator * Game.speedModifier);
					setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
				}
				//move right
				else if(getDistance()<path[1])
				{
					setX(getX()+directions[1]*speed*frames/60*manipulator * Game.speedModifier);
					setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
				}
				//move down again
				else if(getDistance()<path[2])
				{
					setY(getY()+directions[2]*speed*frames/60*manipulator * Game.speedModifier);
					setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
				}
				//move right
				else if(getDistance()<path[3])
				{
					setX(getX()+directions[3]*speed*frames/60*manipulator * Game.speedModifier);
					setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
				}
				//move up
				else if(getDistance()<path[4])
				{
					setY(getY()+directions[4]*speed*frames/60*manipulator * Game.speedModifier);
					setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
				}
				//move right
				else if(getDistance()<path[5])
				{
					setX(getX()+directions[5]*speed*frames/60*manipulator * Game.speedModifier);
					setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
				}
				//move down again
				else if(getDistance()<path[6])
				{
					setY(getY()+directions[6]*speed*frames/60*manipulator * Game.speedModifier);
					setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
				}
				//move left
				else if(getDistance()<path[7])
				{
					setX(getX()+directions[7]*speed*frames/60*manipulator * Game.speedModifier);
					setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
				}
				//move down again
				else if(getDistance()<path[8])
				{
					setY(getY()+directions[8]*speed*frames/60*manipulator * Game.speedModifier);
					setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
				}
				//if virus makes it across the map, then despawn virus
				else
				{
					System.out.println("a virus made it across");
					
					Game.lives--;
					Game.gf.life.setText("Lives: " + Game.lives);
					
					if (Game.lives <= 0)
					{
						Game.gameState = Game.OVER;
					}
					System.out.println(this.toString());
					despawn();
				}
	}
	
	private void setCenterX(int xToSet) 
	{
		x = xToSet - Game.scaleOfSprites*sprite.getWidth(null)/2;
	}
	
	public void setDistance(double distToSet)
	{
		distance=distToSet;
	}
	
	public void setX(double xToSet)
	{
		x=xToSet;
	}
	
	public void setY(double yToSet)
	{
		y=yToSet;
	}
	
	public String toString()
	{
		return id + "th virus. " + "Loc: (" + getX() + "," + getY() +")";
	}
	
}