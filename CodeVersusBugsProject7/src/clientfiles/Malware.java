/**Malware.java
 * Handles movement and drawing of malware.
 * 
 * UPDATE LOG
 * 11/1/14:	
 * 		speed is now in pixels per second
 * 		x, y, and distance are now doubles for more fine tuning
 * 		made checkpoint variables for future use in implementing different paths
 * 11/2/14:	
 * 		drawVirus and moveVirus are no longer static for more logical code
 * 11/12/14:
 * 		2 paths now exist for viruses to follow
 * 		implemented directions and path arrays in moveVirus()
 * 11/15/14:
 * 		added lanes 3,4 and 5 
 * 		[BALANCE] reduced income from viruses ($10 -> $5)
 * 11/23/14:
 * 		added freezing ability and framework for future abilities
 * 11/27/14:
 * 		[BALANCE] increased speed of virus (20 -> 35)
 * TODO
 * see if we are done with this class for now
 * 
 * ----------------------------------------------------------------------
 * 
 * Copyright 2014 Adel Hassan and Patrick Kenney
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package clientfiles;

import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.awt.image.ImageObserver;
import java.io.Serializable;
import java.util.Random;

import javax.swing.ImageIcon;

public abstract class Malware implements Serializable
{
	// for special effects and abilities
	public enum State
	{
		NORMAL, FROZEN, ATTACKING, BENIGN, INVISIBLE
	}
	
	public static Malware allMalware[] = new Malware[10000];
	public static int numMalwares = 0;
	public static final int NORMAL = 0;
	public static final int TANK = 1;
	public static final int RUSH = 2;
	public static boolean routerOn = false;
	public static int routerChance = 20;
	private static Random generator = new Random(31415);
	
	protected boolean offensive = false;
	private boolean toRouter;
	
	public double manipulator = 1;
	/**
	 * The location of the malware in the allMalwares array.
	 */
	public int id;
	protected int health;
	protected int maxHealth;
	protected double x;
	protected double y;
	protected double distance;
	protected int reward;
	protected double elapsedTime = 0;
	protected State state = State.NORMAL;
	public BufferedImage sprite;
	protected static int w = Game.widthOfGamePanel;
	private static int h = Game.heightOfGamePanel;
	public int speed;
	public int type;
	protected int pathPart;
	
	//lanes
	protected static final int[] lane1 = {
			h / 4 - w / 84 * 3,
			h / 4 - w / 84 * 5  + (int) (w * .15),
			h / 4 - w / 84 * 7  + (int) (w * .15) + (int) (h * .4),
			h / 4 - w / 84 * 7  + (int) (w * .15) + (int) (h * .4) + w / 5,
			h / 4 - w / 84 * 9  + (int) (w * .15) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42,
			h / 4 - w / 84 * 11 + (int) (w * .15) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5,
			h / 4 - w / 84 * 13 + (int) (w * .15) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2,
			h / 4 - w / 84 * 15 + (int) (w * .15) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + w / 3 + w / 42,
			h / 4 - w / 84 * 15 + (int) (w * .15) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + w / 3 + w / 42 + (int) (h * .4 + h / 2) - h / 6};
	protected static final int[] directions1 = {1,1,1,1,-1,1,1,1,-1};
	protected static final int[] lane2 = {
			h / 4 - w / 84 * 3,
			h / 4 - w / 84 * 3  + (int) (w * .05),
			h / 4 - w / 84 * 5  + (int) (w * .05) + (int) (h * .4),
			h / 4 - w / 84 * 5  + (int) (w * .05) + (int) (h * .4) + w / 5,
			h / 4 - w / 84 * 7  + (int) (w * .05) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42,
			h / 4 - w / 84 * 9  + (int) (w * .05) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5,
			h / 4 - w / 84 * 11 + (int) (w * .05) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2,
			h / 4 - w / 84 * 13 + (int) (w * .05) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + w / 3 + w / 42,
			h / 4 - w / 84 * 13 + (int) (w * .05) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + w / 3 + w / 42 + (int) (h * .4 + h / 2) - h / 6};
	protected static final int[] directions2 = {1,-1,1,1,-1,1,1,1,-1};
	protected static final int[] lane3 = {
			h / 4 - w / 84 * 3,
			h / 4 - w / 84 * 1  + (int) (w * .18),
			h / 4 - w / 84 * 3  + (int) (w * .18) + (int) (h * .4),
			h / 4 - w / 84 * 3  + (int) (w * .18) + (int) (h * .4) + w / 5,
			h / 4 - w / 84 * 5  + (int) (w * .18) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42,
			h / 4 - w / 84 * 7  + (int) (w * .18) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5,
			h / 4 - w / 84 * 9  + (int) (w * .18) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2,
			h / 4 - w / 84 * 11 + (int) (w * .18) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + w / 3 + w / 42,
			h / 4 - w / 84 * 10 + (int) (w * .18) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + w / 3 + w / 42 + (int) (h * .4 + h / 2) - h / 6};

	protected static final int[] directions3 = {1,-1,1,1,-1,1,1,1,-1};
	protected static final int[] lane4 = {
			(int) (h * .4) - w / 84 * 3,
			(int) (h * .4) - w / 84 * 2 + (int) (w * .14),
			(int) (h * .4) - w / 84 * 2 + (int) (w * .14) + (int) (h * .3),
			(int) (h * .4) - w / 84 * 4 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42),
			(int) (h * .4) - w / 84 * 5 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22),
			(int) (h * .4) - w / 84 * 7 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + w / 3 + w / 42,
			(int) (h * .4) - w / 84 * 7 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + w / 3 + w / 42 + (int) (h * .4 + h / 2) - h / 6,
			(int) (h * .4) - w / 84 * 7 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + w / 3 + w / 42 + (int) (h * .4 + h / 2) - h / 6 + 1,
			(int) (h * .4) - w / 84 * 7 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + w / 3 + w / 42 + (int) (h * .4 + h / 2) - h / 6 + 2};
	protected static final int[] directions4 = {1,1,1,-1,1,1,-1,0,0};
	protected static final int[] lane5 = {
			(int) (h * .4) - w / 84 * 3,
			(int) (h * .4) - w / 84 * 3 + (int) (w * .05),
			(int) (h * .4) - w / 84 * 3 + (int) (w * .05) + (int) (h * .3),
			(int) (h * .4) - w / 84 * 5 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42),
			(int) (h * .4) - w / 84 * 6 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22),
			(int) (h * .4) - w / 84 * 8 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + w / 3 + w / 42,
			(int) (h * .4) - w / 84 * 8 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + w / 3 + w / 42 + (int) (h * .4 + h / 2) - h / 6,
			(int) (h * .4) - w / 84 * 8 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + w / 3 + w / 42 + (int) (h * .4 + h / 2) - h / 6 + 1,
			(int) (h * .4) - w / 84 * 8 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + w / 3 + w / 42 + (int) (h * .4 + h / 2) - h / 6 + 2};
	protected static final int[] directions5 = {1,-1,1,-1,1,1,-1,0,0};
	protected static final int[] routerLane1 = {
		h / 4 - w / 84 * 3,
		h / 4 - w / 84 * 5  + (int) (w * .15),
		h / 4 - w / 84 * 7  + (int) (w * .15) + (int) (h * .4),
		h / 4 - w / 84 * 7  + (int) (w * .15) + (int) (h * .4) + w / 5,
		h / 4 - w / 84 * 9  + (int) (w * .15) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42,
		h / 4 - w / 84 * 11 + (int) (w * .15) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5,
		h / 4 - w / 84 * 13 + (int) (w * .15) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2,
		h / 4 - w / 84 * 15 + (int) (w * .15) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + w / 3 + w / 42,
		h / 4 - w / 84 * 15 + (int) (w * .15) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + w / 3 + w / 42};
	protected static final int[] routerDirections1 = {1,1,1,1,-1,1,1,-1,0};
	protected static final int[] routerLane2 = {
		h / 4 - w / 84 * 3,
		h / 4 - w / 84 * 3  + (int) (w * .05),
		h / 4 - w / 84 * 5  + (int) (w * .05) + (int) (h * .4),
		h / 4 - w / 84 * 5  + (int) (w * .05) + (int) (h * .4) + w / 5,
		h / 4 - w / 84 * 7  + (int) (w * .05) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42,
		h / 4 - w / 84 * 9  + (int) (w * .05) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5,
		h / 4 - w / 84 * 11 + (int) (w * .05) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2,
		h / 4 - w / 84 * 13 + (int) (w * .05) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + w / 3 + w / 42,
		h / 4 - w / 84 * 13 + (int) (w * .05) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + w / 3 + w / 42};
	protected static final int[] routerDirections2 = {1,-1,1,1,-1,1,1,-1,0};
	protected static final int[] routerLane3 = {
		h / 4 - w / 84 * 3,
		h / 4 - w / 84 * 1  + (int) (w * .18),
		h / 4 - w / 84 * 3  + (int) (w * .18) + (int) (h * .4),
		h / 4 - w / 84 * 3  + (int) (w * .18) + (int) (h * .4) + w / 5,
		h / 4 - w / 84 * 5  + (int) (w * .18) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42,
		h / 4 - w / 84 * 7  + (int) (w * .18) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5,
		h / 4 - w / 84 * 9  + (int) (w * .18) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2,
		h / 4 - w / 84 * 11 + (int) (w * .18) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + w / 3 + w / 42,
		h / 4 - w / 84 * 11 + (int) (w * .18) + (int) (h * .4) + w / 5 + (h / 4) + (int) (h * .4) - (2 * w / 42) - (int) (h * .4) + w / 42 + w / 5 + h / 2 + w / 3 + w / 42
	};
	protected static final int[] routerDirections3 = {1,-1,1,1,-1,1,1,-1,0};
	protected static final int[] routerLane4 = {
		(int) (h * .4) - w / 84 * 3,
		(int) (h * .4) - w / 84 * 2 + (int) (w * .14),
		(int) (h * .4) - w / 84 * 2 + (int) (w * .14) + (int) (h * .3),
		(int) (h * .4) - w / 84 * 4 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42),
		(int) (h * .4) - w / 84 * 5 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22),
		(int) (h * .4) - w / 84 * 7 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + w / 3 + w / 42,
		(int) (h * .4) - w / 84 * 7 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + w / 3 + w / 42 + 1,
		(int) (h * .4) - w / 84 * 7 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + w / 3 + w / 42 + 1,
		(int) (h * .4) - w / 84 * 7 + (int) (w * .14) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + w / 3 + w / 42 + 1
	};
	protected static final int[] routerDirections4 = {1,1,1,-1,1,-1,0,0,0};
	protected static final int[] routerLane5 = {
		(int) (h * .4) - w / 84 * 3,
		(int) (h * .4) - w / 84 * 3 + (int) (w * .05),
		(int) (h * .4) - w / 84 * 3 + (int) (w * .05) + (int) (h * .3),
		(int) (h * .4) - w / 84 * 5 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42),
		(int) (h * .4) - w / 84 * 6 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22),
		(int) (h * .4) - w / 84 * 8 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + w / 3 + w / 42,
		(int) (h * .4) - w / 84 * 8 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + w / 3 + w / 42 + 1,
		(int) (h * .4) - w / 84 * 8 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + w / 3 + w / 42 + 1,
		(int) (h * .4) - w / 84 * 8 + (int) (w * .05) + (int) (h * .3) + (int) (w * .8) - ((int) (w * .4) + (w / 5) - (w / 42) + (w / 42)) + (2 * w / 42) + (int) (h * .22) + w / 3 + w / 42 + 1
	};
	protected static final int[] routerDirections5 = {1,-1,1,-1,1,-1,0,0,0};
	
	protected int[] path;
	protected int[] directions;
	
	/**creates a virus in the lane specified, at the chosen y value. 
	 * Lanes are numbered from left to right.
	 * 
	 * @param y
	 */
	public Malware(int type, int lane, int y)
	{
		setY(y);
		setDistance(y);
		
		id = numMalwares;
		numMalwares++;
		//code for setting sprite based on malware type
		//CANT be done in subclasses because setCenterX() needs a non-null sprite
		if(this instanceof Minion)
		{
			if(type == NORMAL)
				sprite=Minion.sprite;
			else if(type == TANK)
				sprite=Minion.tankSprite;
			else if(type == RUSH)
				sprite = Minion.rushSprite;
		}
		else if(this instanceof Worm)
			sprite = Worm.sprite;
		else if(this instanceof Trojan)
			sprite = Trojan.sprite;
		else if(this instanceof Virus)
		{
			if(type == NORMAL)
				sprite = Virus.sprite;
			else if(type == TANK)
				sprite = Virus.tankSprite;
			else if(type == RUSH)
				sprite = Virus.rushSprite;
		}
		else if(this instanceof Spyware)
			sprite = Spyware.sprite;
		else if(this instanceof Bot)
			sprite = Bot.sprite;
		
		this.type = type;
		
		//set the path of the malwares
		if(!routerOn || (routerOn && generator.nextInt(100) >= routerChance))
		{
			toRouter = false;
			switch(lane)
			{
				case 1:
					path = lane1;
					directions = directions1;
					setCenterX(w / 14 + (w / 84));
					break;
				case 2:
					path = lane2;
					directions = directions2;
					setCenterX(w / 4 + (w / 84));
					break;
				case 3:
					path = lane3;
					directions = directions3;
					setCenterX((int) (w * .4) + (w / 84));
					break;
				case 4:
					path = lane4;
					directions = directions4;
					setCenterX((int) (w * .65) + (w / 84));
					break;
				case 5:
					path = lane5;
					directions = directions5;
					setCenterX((int) (w * .85) + (w / 84));
					break;
				default:
					path = lane1;
					directions = directions1;
					setCenterX(w / 14 - (w / 84));
			}
		}
		else
		{
			toRouter = true;
			switch(lane)
			{
				case 1:
					path = routerLane1;
					directions = routerDirections1;
					setCenterX(w / 14 + (w / 84));
					break;
				case 2:
					path = routerLane2;
					directions = routerDirections2;
					setCenterX(w / 4 + (w / 84));
					break;
				case 3:
					path = routerLane3;
					directions = routerDirections3;
					setCenterX((int) (w * .4) + (w / 84));
					break;
				case 4:
					path = routerLane4;
					directions = routerDirections4;
					setCenterX((int) (w * .65) + (w / 84));
					break;
				case 5:
					path = routerLane5;
					directions = routerDirections5;
					setCenterX((int) (w * .85) + (w / 84));
					break;
				default:
					System.out.println("a malware was created with an invalid lane.");
			}
		}
	}
	
	/**
	 * Deals damage to the selected virus equal to the argument's value
	 * 
	 * @param damage damage to deal
	 * @param manipulatorToSet reduces speed of malware
	 */
	public void dealDamage(double damage, double manipulatorToSet, int idOfTower)
	{
		manipulator = manipulatorToSet;
		
		if (manipulatorToSet == 0)
			state = State.FROZEN;
		
		health -= damage;
		//disintegrate if not a worm
		if(!(this instanceof Worm) && health > 0 && damage > 0)
		{
			BufferedImage newSprite = new BufferedImage(sprite.getWidth(), sprite.getHeight(), BufferedImage.TYPE_INT_ARGB);
			Graphics g = newSprite.getGraphics();
			g.drawImage(sprite, 0, 0, null);
			g.dispose();
			int percentLeft = 100 * health / maxHealth;
			//System.out.println("percentLeft = " + percentLeft);
			int area = sprite.getHeight() * sprite.getWidth();
			//System.out.println("area = " + area);
			int pixelsToDo = area - area * percentLeft / 100;
			//System.out.println("pixelsToDo = " + pixelsToDo);
			int interval = area / pixelsToDo;
			//System.out.println("interval = " + interval);
			int pixelsDone = 0;
			int x = 0;
			int y = 0;
			//systematically for scanners
			if(Tower.allTowers[idOfTower] instanceof Scanner)
			{
				while(pixelsDone < pixelsToDo)
				{
					int clr = sprite.getRGB(x, y);
					
					//transparent
					if((clr & 0xff000000) >> 24 != 0)
						newSprite.setRGB(x, y, (0 << 24) | (0 << 16) | (0 << 8) | 0);
					//black
					//if((clr & 0xff000000) >> 24 != 0)
					//	newSprite.setRGB(x, y, (255 << 24) | (0 << 16) | (0 << 8) | 0);
					
					sprite = newSprite;
					
					//move on to next pixel
					x += interval;
					pixelsDone++;
					if(x >= sprite.getWidth())
					{
						y++;
						while(x >= sprite.getWidth())
							x -= sprite.getWidth();
					}
					if(y >= sprite.getHeight())
					{
						y-= sprite.getHeight();
					}
				}
			}
			//randomly
			else
				while(pixelsDone < pixelsToDo)
				{
					//debug
					//System.out.println("x: " + x + ", y: " + y);
					int clr = sprite.getRGB(x, y);
					int red   = (clr & 0x00ff0000) >> 16;
					int green = (clr & 0x0000ff00) >> 8;
					int blue  =  clr & 0x000000ff;
					int alpha = 0;
					
					//transparent
					//if((clr & 0xff000000) >> 24 != 0)
					//	newSprite.setRGB(x, y, (0 << 24) | (0 << 16) | (0 << 8) | 0);
					//black
					//keep looking until non-transparent is found
					do
					{
						//System.out.println("looking at "+x+" "+y);
						x = generator.nextInt(sprite.getWidth());
						y = generator.nextInt(sprite.getHeight());
						clr = sprite.getRGB(x, y);
						//red   = (clr & 0x00ff0000) >> 16;
						//green = (clr & 0x0000ff00) >> 8;
						//blue  =  clr & 0x000000ff;
						//alpha = 0;
					}while(!((clr & 0xff000000) >> 24 != 0));
					//System.out.println("found at "+x+" "+y);
					newSprite.setRGB(x, y, (1 << 24) | (0 << 16) | (0 << 8) | 0);
					
					//move on to next pixel
					pixelsDone++;
				}
			
			//finally, update sprite
			sprite = newSprite;
		}
		
		// increase number of hits for killer
		if (Tower.allTowers[idOfTower] != null)
			Tower.allTowers[idOfTower].hits++;
		
		if(health <= 0)
		{
			Game.addMoney(reward);
			
			// increase number of kills for killer
			if (Tower.allTowers[idOfTower] != null)
				Tower.allTowers[idOfTower].kills++;
			
			despawn();
		}
		
		// re-draw tower panel with updated statistics
		if (idOfTower == Upgrades.displayedUpgradeID && Tower.allTowers[idOfTower] != null)
			Upgrades.updateStatistics();
	}

	/**
	 * Removes the virus from the allMalware array.
	 */
	public void despawn()
	{
		//play sound
		Game.playSound("malwareDeath1.wav");
		
		//save the dead virus's ID and reduce total number of viruses
		int deadVirusID=id;
		numMalwares--;
		
		//move all other viruses in array
		for(int v=deadVirusID; v<allMalware.length; v++)
		{
			allMalware[v] = allMalware[v+1];
			
			//break once reaches the nulls
			if(allMalware[v] == null)
				break;
			
			//change the virus's id to its new location in the array
			allMalware[v].id = v;
		}
		
		if (numMalwares == 0)
		{
			Game.gameState = Game.PAUSED;
			Game.pauseButton.setIcon(PauseButtonListener.sprite);
			Game.addMoney(50);
			
			Game.level++;
			Game.gf.life.setDisplay(Game.lives);
			Game.gf.levelCounter.setDisplay(Game.level);
			
			if (Game.level != 51)
			{
				Game.techPanel.pointsToSpend++;
				Game.gamePanel.setVisible(false);
				Game.techPanel.setVisible(true);
			}
			
			// removed start next round and replaced with variable that is used in actionlistener for Game class to decide when to start next round - 3:08pm - 11/24/2014
			Game.endOfRound = true;
			
			if (Game.level == 51)
				Game.gameState = Game.WON;
		}
	}
	public void draw(Graphics g)
	{
		if(health>0)
		{
			AffineTransform at = new AffineTransform();
			at.scale(Game.xScale, Game.yScale);
			at.translate((int)getX() / Game.xScale, (int) getY() / Game.yScale);
			Graphics2D g2D = (Graphics2D) g;
			g2D.drawImage(sprite, at, null);
			if(state == State.FROZEN)
				g2D.drawImage(MyImages.stun, at, null);
		}
	}
	public int getCenterX()
	{
		return (int) x + sprite.getWidth(null)/2;
	}
	public int getCenterY()
	{
		return (int) y + sprite.getHeight(null)/2;
	}
	public double getDistance()
	{
		return distance;
	}
	public int getHealth()
	{
		return health;
	}
	// for use in targeting
	public double getRelativeDistance()
	{
		if (getCenterY() < 0)
			return distance;
		else if (path == lane1)
			return distance + 47;
		else if (path == lane2)
			return distance + 131;
		else if (path == lane3)
			return distance;
		else if (path == lane4)
			return distance + 337;
		else if (path == lane5)
			return distance + 457;
		else
			return distance;
	}
	public double getX()
	{
		return x;
	}
	public double getY()
	{
		return y;
	}
	
	/**call this method on a virus object to move the malware
	 * 
	 * @param frames the interpolation
	 */
	public void move(double frames)
	{
		// timer for frozen viruses
		if (state == State.FROZEN && elapsedTime < 5)
		{
			elapsedTime += frames/60;
			if (Game.fastForward)
				elapsedTime += frames/60;
		}
		// to be changed later
		else // reseting
		{
			manipulator = 1;
			elapsedTime = 0;
			state = State.NORMAL;
		}
				
		//move down for first stretch
		if(getDistance()<path[0]) //if distance traveled is less than 2st item in array, then move down
		{
			setY(getY()+directions[0]*speed*frames/60*manipulator * Game.speedModifier);
			setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
			pathPart = 0;
			
			if(getDistance() > path[0]/2)
			{
				//special cases for minion types tutorial reel
				if(Game.tutorial && Game.tutorialSlide <= 33 && type == RUSH)
					Game.gamePanel.nextSlide();
				if(Game.tutorial && Game.tutorialSlide <= 37 && type == TANK)
					Game.gamePanel.nextSlide();
				if(Game.tutorial && Game.tutorialSlide <= 107 && this instanceof Spyware)
					Game.gamePanel.nextSlide();
				if(Game.tutorial && Game.tutorialSlide <= 120 && this instanceof Bot)
					Game.gamePanel.nextSlide();
			}
		}
		//move right
		else if(getDistance()<path[1])
		{
			setX(getX()+directions[1]*speed*frames/60*manipulator * Game.speedModifier);
			setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
			pathPart = 1;
		}
		//move down again
		else if(getDistance()<path[2])
		{
			setY(getY()+directions[2]*speed*frames/60*manipulator * Game.speedModifier);
			setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
			pathPart = 2;
		}
		//move right
		else if(getDistance()<path[3])
		{
			setX(getX()+directions[3]*speed*frames/60*manipulator * Game.speedModifier);
			setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
			pathPart = 3;
		}
		//move up
		else if(getDistance()<path[4])
		{
			setY(getY()+directions[4]*speed*frames/60*manipulator * Game.speedModifier);
			setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
			pathPart = 4;
		}
		//move right
		else if(getDistance()<path[5])
		{
			setX(getX()+directions[5]*speed*frames/60*manipulator * Game.speedModifier);
			setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
			pathPart = 5;
		}
		//move down again
		else if(getDistance()<path[6])
		{
			setY(getY()+directions[6]*speed*frames/60*manipulator * Game.speedModifier);
			setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
			pathPart = 6;
		}
		//move right
		else if(getDistance()<path[7])
		{
			setX(getX()+directions[7]*speed*frames/60*manipulator * Game.speedModifier);
			setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
			pathPart = 7;
		}
		//move up to cpu
		else if(getDistance()<path[8])
		{
			setY(getY()+directions[8]*speed*frames/60*manipulator * Game.speedModifier);
			setDistance(getDistance()+speed*frames/60*manipulator * Game.speedModifier);
			pathPart = 8;
		}
		//if virus makes it across the map, then despawn virus
		else if(!toRouter)
		{
			System.out.println("a malware made it across");
			
			Game.lives-=health;
			Game.gf.life.setDisplay(Game.lives);
			
			if (Game.lives <= 0)
			{
				Game.gameState = Game.OVER;
			}
			
			System.out.println(this);
			despawn();
		}
		//virus that makes it to decoy CPU despawns w/o taking away lives
		else
		{
			despawn();
		}
	}
	protected void setCenterX(int xToSet) 
	{
		x = xToSet - Game.xScale*sprite.getWidth(null)/2;
	}
	
	public void setDistance(double distToSet)
	{
		distance=distToSet;
	}
	
	public void setX(double xToSet)
	{
		x=xToSet;
	}
	
	public void setY(double yToSet)
	{
		y=yToSet;
	}
	
	public String toString()
	{
		return id + "th virus. " + "Loc: (" + getX() + "," + getY() +")";
	}
	
}